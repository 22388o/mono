/**
 * @file Interface to the Ethereum network
 */

const { BaseClass } = require('@portaldefi/core')
const { Web3, WebSocketProvider } = require('web3')

/**
 * Holds private fields for instances of the class
 * @type {WeakMap}
 */
const INSTANCES = new WeakMap()

/**
 * Interface to the Ethereum network
 * @type {Ethereum}
 */
module.exports = class Ethereum extends BaseClass {
  constructor (sdk, props) {
    super({ id: 'ethereum' })

    const log = (level, event) => {
      return [event, (...args) => this[level](`provider.${event}`, ...args)]
    }

    // web3-provider
    const provider = new WebSocketProvider(props.url)

    // web3
    const web3 = new Web3(provider)

    // account/wallet
    const wallet = web3.eth.accounts.wallet.add(`0x${props.private}`)

    // default configuration
    web3.eth.defaultAccount = wallet[0].address
    web3.eth.Contract.handleRevert = true

    // swap contract
    const { abi, address } = props.contracts.Swap
    const { address: from } = wallet[0]
    const contract = new web3.eth.Contract(abi, address, { from })
    contract.handleRevert = true
    contract.defaultAccount = wallet[0].address
    contract.defaultChain = 'mainnet'
    contract.defaultHardfork = 'petersburg'
    contract.defaultNetworkId = props.chainId
    contract.defaultCommon = {
      name: 'playnet',
      chainId: props.chainId,
      networkId: props.chainId
    }

    // swap contract events
    const events = contract.events.allEvents()
    events.on('connected', id => this.debug('contract.events', { id }))
    events.on('data', data => {
      const { event, address, returnValues } = data
      this.info(`contract.${event}`, data)

      if (contract._address !== address) {
        const err = Error(`got event from ${address} instead of ${contract._address}`)
        this.emit('error', err)
      }

      switch (event) {
        case 'InvoiceCreated': {
          const { id, swap, payee, asset, quantity } = returnValues
          this.emit('invoice.created', { id, swap: { id: swap }, payee, asset, quantity })
          break
        }

        case 'InvoicePaid': {
          const { id, swap, payer, asset, quantity } = returnValues
          this.emit('invoice.paid', { id, swap: { id: swap }, payer, asset, quantity })
          break
        }

        case 'InvoiceSettled': {
          const { id, swap, payer, payee, asset, quantity } = returnValues
          const bnSecret = web3.utils.toBN(returnValues.secret)
          console.log('bnSecret', bnSecret)
          const secret = bnSecret.toHexString().substr(2)
          console.log('secret', secret)
          this.emit('invoice.settled', { id, swap: { id: swap, secret }, payer, payee, asset, quantity })
          break
        }

        default:
          this.debug('event', data)
      }
    })
    events.on('changed', data => this.warn('subscription.changed', data))
    events.on('error', (err, receipt) => this.error('subscription.error', err, receipt))

    // json
    const json = {
      wallet: wallet[0].address,
      contract: { address: contract._address }
    }

    INSTANCES.set(this, Object.seal({ web3, wallet, contract, events, json }))

    Object.freeze(this)
  }

  /**
   * Returns the JSON representation of the swap
   * @returns {Object}
   */
  toJSON () {
    const { json } = INSTANCES.get(this)
    return Object.assign(super.toJSON(), json)
  }

  /**
   * Initializes the connection to the geth daemon
   * @returns {Promise<Ethereum>}
   */
  async connect () {
    try {
      this.emit('connect', this)
      return this
    } catch (err) {
      this.error('connect', err, this)
      throw err
    }
  }

  /**
   * Creates an invoice
   * @param {Party} party The party that is creating the invoice
   * @param {Number} party.quantity The number of tokens to be invoiced
   * @param {Swap} party.swap The parent swap of the party
   * @param {String} party.swap.secretHash The hash of the secret of the swap
   * @returns {Promise<String>} The invoice generated by the Swap contract
   */
  async createInvoice(party) {
    try {
      const { web3, contract } = INSTANCES.get(this)
      const { swap: { id, secretHash }, asset, quantity } = party
      const value = web3.utils.toHex(quantity)
      // TODO: Fix the hard coded values to account for ERC-20 tokens as well
      console.log('createInvoice', value)
      const transaction = contract.methods.createInvoice(
        `0x${secretHash}`,
        `0x${id}`,
        '0x0000000000000000000000000000000000000000',
        value
      )
      const gas = await transaction.estimateGas()
      const receipt = await transaction.send({ gas })
      this.info('createInvoice', receipt, party, this)

      return id
    } catch (err) {
      this.error('createInvoice', err, party, this)
      throw err
    }
  }

  /**
   * Pays an invoice
   * @param {Party} party The party that is paying the invoice
   * @param {Number} party.invoice The invoice to be paid
   * @param {Number} party.quantity The number of tokens to be invoiced
   * @param {Swap} party.swap The parent swap of the party
   * @param {String} party.swap.secretHash The hash of the secret of the swap
   * @returns {Promise<Void>}
   */
  async payInvoice(party) {
    try {
      const { web3, contract } = INSTANCES.get(this)
      const { swap: { id, secretHash }, asset, quantity } = party
      const value = web3.utils.toHex(quantity)
      const transaction = contract.methods.payInvoice(
        `0x${secretHash}`,
        `0x${id}`,
        '0x0000000000000000000000000000000000000000',
        value
      )
      // TODO: fix value to only be used for ETH transactions
      const gas = await transaction.estimateGas({ value })
      const receipt = await transaction.send({ gas, value })
    } catch (err) {
      this.error('payInvoice', err, party, this)
      throw err
    }
  }

  /**
   * Settles an invoice
   * @param {Party} party The party that is settling the invoice
   * @param {Number} party.invoice The invoice to be settled
   * @param {String} secret The secret to be revealed during settlement
   * @returns {Promise<Void>}
   */
  async settleInvoice(party, secret) {
    try {
      const { web3, contract } = INSTANCES.get(this)
      const { swap: { id } } = party
      const transaction = contract.methods.settleInvoice(
        `0x${secret.toString('hex')}`,
        `0x${id}`
      )
      const gas = await transaction.estimateGas()
      // TODO: fix value to only be used for ETH transactions
      const receipt = await transaction.send({ gas })
      console.log('got receipt', receipt)
    } catch (err) {
      this.error('settleInvoice', err, party, this)
      throw err
    }
  }

  /**
   * Gracefully disconnects from the geth daemon
   * @returns {Promise<Ethereum>}
   */
  async disconnect () {
    try {
      const { web3, subscriptions } = INSTANCES.get(this)

      for (const name in subscriptions) {
        const subscription = subscriptions[name]
        if (subscription != null) {
          await subscription.unsubscribe()
          subscriptions[name] = null
        }
      }

      this.emit('disconnect', this)
      return this
    } catch (err) {
      this.error('disconnect', err, this)
      throw err
    }
  }
}
