/**
 * @file Interface to the Ethereum network
 */

const { BaseClass } = require('@portaldefi/core')
const { Web3, WebSocketProvider } = require('web3')

/**
 * Holds private fields for instances of the class
 * @type {WeakMap}
 */
const INSTANCES = new WeakMap()

/**
 * Interface to the Ethereum network
 * @type {Ethereum}
 */
module.exports = class Ethereum extends BaseClass {
  constructor (sdk, props) {
    super({ id: 'ethereum' })

    const log = (level, event) => {
      return [event, (...args) => this[level](event, ...args)]
    }
    const provider = new WebSocketProvider(props.url)
    provider.on(...log('error', 'error'))
    provider.on(...log('debug', 'message'))
    provider.on(...log('debug', 'connect'))
    provider.on(...log('debug', 'chainChanged'))
    provider.on(...log('debug', 'accountsChanged'))
    provider.on(...log('debug', 'disconnect'))

    // web3
    const web3 = new Web3(provider)

    // account and wallet
    const wallet = web3.eth.accounts.wallet.add(`0x${props.private}`)

    // default configuration
    web3.eth.defaultAccount = wallet[0].address
    web3.eth.Contract.handleRevert = true

    // smart contracts
    const contracts = {}
    for (const name in props.contracts) {
      const { abi, address } = props.contracts[name]
      const { address: from } = wallet[0]
      const contract = new web3.eth.Contract(abi, address, { from })

      // contract configuration
      contract.handleRevert = true
      contract.defaultAccount = wallet[0].address
      contract.defaultChain = 'mainnet'
      contract.defaultHardfork = 'petersburg'
      contract.defaultNetworkId = props.chainId
      contract.defaultCommon = {
        name: 'playnet',
        chainId: props.chainId,
        networkId: props.chainId
      }

      contracts[name] = contract
    }

    // subscriptions
    const subscriptions = {
      logs: null,
      newBlockHeaders: null,
      newPendingTransactions: null,
      syncing: null
    }

    INSTANCES.set(this, Object.seal({
      web3,
      wallet,
      contracts,
      subscriptions,
      json: {
        wallet: wallet[0].address,
        contracts: Object.keys(contracts).reduce((obj, name) => {
          obj[name] = {
            address: contracts[name]._address,
            config: contracts[name].config
          }
          return obj
        }, {})
      }
    }))

    Object.freeze(this)
  }

  /**
   * Returns the JSON representation of the swap
   * @returns {Object}
   */
  toJSON () {
    const { json } = INSTANCES.get(this)
    return Object.assign(super.toJSON(), json)
  }

  /**
   * Initializes the connection to the geth daemon
   * @returns {Promise<Ethereum>}
   */
  async connect () {
    try {
      const { web3, subscriptions } = INSTANCES.get(this)

      for (const name in subscriptions) {
        const subscription = await web3.eth.subscribe(name)
        subscription.on('connected', (...args) => console.log(`subscription.${name}.connected`, ...args))
        subscription.on('data', (...args) => console.log(`subscription.${name}.data`, ...args))
        subscription.on('error', (...args) => console.log(`subscription.${name}.error`, ...args))
        subscriptions[name] = subscription
      }

      return this
    } catch (err) {
      this.error('connect', err, this)
      throw err
    }
  }

  /**
   * Creates an invoice
   * @param {Object} args Arguments for the operation
   * @returns {Promise<String>} The invoice generated by the Swap contract
   */
  async createInvoice (args) {
    try {
      const { web3, wallet, contracts: { Swap } } = INSTANCES.get(this)
      const { id, secretHash, asset, quantity } = args
      // TODO: Fix the hard coded values to account for ERC-20 tokens as well
      const transaction = Swap.methods.createInvoice(
        '0x0000000000000000000000000000000000000000',
        web3.utils.toHex(quantity),
        '0'
      )
      const gas = await transaction.estimateGas()
      const receipt = await transaction.send({ gas })
      const hex = receipt.logs[0].data.substr(2, 64)
      const dec = parseInt(hex, 16)
      return dec.toString()
    } catch (err) {
      this.error('createInvoice', err, this)
      throw err
    }
  }

  /**
   * Gracefully disconnects from the geth daemon
   * @returns {Promise<Ethereum>}
   */
  async disconnect () {
    try {
      const { web3, subscriptions } = INSTANCES.get(this)

      for (const name in subscriptions) {
        const subscription = subscriptions[name]
        await subscription.unsubscribe()
        subscriptions[name] = null
      }

      return this
    } catch (err) {
      this.error('disconnect', err, this)
      throw err
    }
  }
}
