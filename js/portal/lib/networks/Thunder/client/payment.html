<html>

<head>
    <script src="
    https://cdn.jsdelivr.net/npm/@metamask/legacy-web3@2.0.0/dist/metamask.web3.min.js
    "></script>
</head>

<body>
    <h1>Send L2 payment</h1>

    <button id="connect" onclick="connect()">Connect Web3</button>    
    <b>Your Address</b><br/>
    <span id="address" style="font-family: monospace;"></span><br />

    <hr />

    <br />
    <b>Target Address</b><br/>
    <input id="target" value="0x8584223Ea6Bd70d30FbA40175595F0F09a61cA2a" style="font-family:monospace; width:360px" /><br />
    
    <br />
    <b>Channel Id</b> <br />
    <span id="channel" style="font-family:monospace;"></span><br />
    <b>Channel Balance</b><br/>
    <span id="channel-balance"></span><br /><br />



    <!--Channel <br />
    <input id="channel" value="0xce1285848482e532d3dc47fa492e8269d3f4365377491cee04de4d6af995331a" /><br />-->
    
    <div id="open-channel"  style="display:none">
        <b>Channel Capacity</b> <br />
        <input id="capacity" value="1000" /><br />    
        <button id="open-channel" onclick="openChannel()">Open Channel</button>
    </div>

    <div id="send-payment" style="display:none">
        <b>Payment Amount</b> <br />
        <input id="amount" value="55" /><br />    
        <button id="send-payment" onclick="sendPayment()">Send</button>
    </div>
</body>

<script>
function getChannelContractAddress(){
    let channelContractAddress = '0xa95d15f30E369151af5bf89dA1074ff1B6666864';
    return channelContractAddress;
}

ETH =  '0x0000000000000000000000000000000000000000';
baseRpcUrl = `http://localhost:3000`;
channelInfo = null;

function getChannelId(sourceAddress, targetAddress, tokenAddress){  
    if(!tokenAddress) throw("provide tokenAddress to getChannelId");
    //TODO include token in channel id preimage              
    let buffer = concatHex(getChannelContractAddress(), sourceAddress, targetAddress, tokenAddress); //
    return web3.sha3(buffer, {encoding: 'hex'});
}

function concatHex(){
    var args = Array.prototype.slice.call(arguments);
    return '0x' + args.map(x => x.startsWith('0x') ? x.substr(2) : x ).join('');
}

function decToUint256Hex(value){
    let res = parseInt(value).toString(16).padStart(64, '0');        
    return res;
}

function encodeTransferForSig(params){            
    let message = concatHex(getChannelContractAddress(), params.channelId, decToUint256Hex(params.spent));        
    console.log("ENCODED TX", message);

    let hash = web3.sha3(message, {encoding: 'hex'}); //this.web3new.utils.keccak256(message);

    console.log("ENCODED TX HASH", hash);

    return hash;
}


async function getHttp(url) {
    return new Promise((resolve, reject) =>{
        // Creating Our XMLHttpRequest object 
        var xhr = new XMLHttpRequest();

        // Making our connection                  
        xhr.open("GET", url, true);

        // function execute after request is successful 
        xhr.onreadystatechange = function () {
            if (this.readyState == 4 && this.status == 200) {
                //console.log(this.responseText);
                console.log("AJAX RESULT",this.responseText);
                let result = JSON.parse(this.responseText);                
                resolve(result);
            }

            if(this.status != 200){
                reject("failed ajax call");
            }
        }
        // Sending our request 
        xhr.send();
    });
}

function getParams(params){
    return Object.keys(params).map(k => k + '=' + params[k]).join('&')
}

async function openChannel(){
    let capacity = document.getElementById('capacity').value;
    let target = document.getElementById('target').value;
    let token = ETH;
    let myaddress = web3.eth.accounts[0];
    let channelId = getChannelId(myaddress, target, token);

    if(!capacity.startsWith('0x')) capacity = '0x'+parseInt(capacity).toString('16')

    let openUrl = baseRpcUrl + `/channel/open?` + getParams({
        target: target,
        capacity: capacity,
        token: token,        
    });

    console.log("OPEN URL", openUrl);

    let opened = await getHttp(openUrl);

    console.log("OPEN RESULT", opened);

    loadChannel();
}

async function sendPayment(){
    //let chan = document.getElementById('channel').value;
    let amount = document.getElementById('amount').value;
    let target = document.getElementById('target').value;
    let token = ETH;

    let myaddress = web3.eth.accounts[0];

    let channelId = getChannelId(myaddress, target, token);

    //if(channelId != chan) throw "wrong computed channel";

    let spent = parseInt(channelInfo.channel.spent) + parseInt(amount);

    console.log("SPENT", spent);

    let encoded = encodeTransferForSig({
        channelId: channelId,
        spent: spent,
    })

    const signature = await ethereum.request({ method: 'personal_sign', params: [ encoded, myaddress ] });

    console.log("SIG", signature);

    let transferUrl = baseRpcUrl + `/transfer?` + getParams({
        target: target,
        amount: amount,
        spent: spent,
        token: token,
        signature: signature,
    });
    console.log("TRANSFER URL", transferUrl)
    let transfer = await getHttp(transferUrl);

    console.log("TRANSFER", transfer);

    if(transfer.status === 'success'){
        setTimeout(async () => {
            let revealUrl = baseRpcUrl + '/reveal?' + getParams({secret: transfer.secret})
            console.log("REVEALING SECRET", revealUrl);
            let revealed = await getHttp(revealUrl);
            console.log("REVEALED", revealed);

            loadChannel();
        }, 1500)
    }
    
}

async function loadChannel(){
    let target = document.getElementById('target').value;
    let token = ETH;
    let myaddress = web3.eth.accounts[0];

    let channelId = getChannelId(myaddress, target, token);

    document.getElementById('channel').innerHTML = channelId;

    let info = await getHttp(baseRpcUrl + "/channel?id=" + channelId );

    console.log(info);
    document.getElementById('channel-balance').innerHTML = info.balance;

    if(info.channel == null){
        document.getElementById('open-channel').style.display="block"
        document.getElementById('send-payment').style.display="none"
    }else if(info.balance == 0){
        //TODO add more channelf unds
    }else{
        document.getElementById('open-channel').style.display="none"
        document.getElementById('send-payment').style.display="block"
    }

    channelInfo = info;
}


async function connect() {
 if (window.ethereum) {
 
  await window.ethereum.request({ method: "eth_requestAccounts" });
  window.web3 = new Web3(window.ethereum);
  
 } else {
  console.log("No wallet");
 }
}

window.addEventListener('load', async function() {


    // Load WEB3
    // Check wether it's already injected by something else (like Metamask or Parity Chrome plugin)
    if(typeof web3 !== 'undefined') {
        console.log("USING INJECTED WEB3");
        web3 = new Web3(web3.currentProvider);  

    // Or connect to a node
    } else {
        web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
    }

    // Check the connection
    if(!web3.isConnected()) {
        console.error("Not connected");

    }

    function loadAccount(){
        account = web3.eth.accounts[0];
        document.getElementById("address").innerHTML = account;  
        if(account){
            document.getElementById('connect').style.display = 'none';
        }
    }

    var account = web3.eth.accounts[0];
    var accountInterval = setInterval(function() {
        if (web3.eth.accounts[0] !== account) {
            loadAccount();
        }
    }, 100);

    loadAccount();          
    //document.getElementById('channel').innerHTML = getChannelId();
    
    setTimeout(() => {
        loadChannel();
    }, 500);
    
});

</script>

</html>